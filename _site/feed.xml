<?xml version="1.0" encoding="utf-8"?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kadie Jaffe</title>
    <description></description>
    <link>http://kadie16.github.io/</link>
    <atom:link href="http://kadie16.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 26 Feb 2016 20:38:29 -0800</pubDate>
    <lastBuildDate>Fri, 26 Feb 2016 20:38:29 -0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>My First Maya Project</title>
        <description>&lt;p&gt;This semester I am taking a decal called UCBUGG, which stands for UC Berkeley Undergraduate Graphics Group. We are learning how to make an animated short using maya! This is my first maya project. He is a little robot. I don’t have a name for him but I think he is pretty cute. Some people said he looks like a penguin. My former supervisor Like thinks he looks like a bumble bee :)&lt;/p&gt;

&lt;center&gt;&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/plv-S4iDUYM&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;I used &lt;a href=&quot;http://ucbugg-labs.wikispaces.com/Introduction+to+Maya&quot;&gt;this tutorial&lt;/a&gt; to make this little guy. It was super helpful! The whole website has a lot of great tutorials if you are just starting out with Maya like I am.&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Feb 2016 00:00:00 -0800</pubDate>
        <link>http://kadie16.github.io/maya-robot/</link>
        <guid isPermaLink="true">http://kadie16.github.io/maya-robot/</guid>
        
        <category>Java</category>
        
        
        <category>projects</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>My First Maya Project</title>
        <description>&lt;p&gt;This semester I am taking a decal called UCBUGG, which stands for UC Berkeley Undergraduate Graphics Group. We are learning how to make an animated short using maya! This is my first maya project. He is a little robot. I don’t have a name for him but I think he is pretty cute. Some people said he looks like a penguin. My former supervisor Like thinks he looks like a bumble bee :)&lt;/p&gt;

&lt;center&gt;&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/plv-S4iDUYM&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;I used &lt;a href=&quot;http://ucbugg-labs.wikispaces.com/Introduction+to+Maya&quot;&gt;this tutorial&lt;/a&gt; to make this little guy. It was super helpful! The whole website has a lot of great tutorials if you are just starting out with Maya like I am.&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Feb 2016 00:00:00 -0800</pubDate>
        <link>http://kadie16.github.io/maya-robot/</link>
        <guid isPermaLink="true">http://kadie16.github.io/maya-robot/</guid>
        
        <category>Java</category>
        
        
        <category>featured</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>Rasterizester Project</title>
        <description>&lt;h2 align=&quot;middle&quot;&gt;Part 1: Rasterizing Lines&lt;/h2&gt;
&lt;p&gt;I used Bresenham&#39;s algorithm to rasterize lines. In order to rasterize the line, the algorithm needs to decide which pixels lie closest to it. The line will not directly intersect the center of every pixel, so it must be decided which pixels it intersects the most. To do this, it steps through the line, incrementing the x coordinate by one if the overall change in x is greater than the overall change in y, or incrementing the y coordinate if the opposite is true. For this description I will assume we are rasterizing a line dx &amp;gt; dy. &lt;/p&gt;
&lt;p&gt; Then the algorithm needs to make a decision about which pixel is closest to the next point on the line. It uses a decision parameter pk. If pk is less than zero, it plots the point (x, y) and increments pk by 2*dy. Otherwise, it plots the point (x, y + 1) or (x, y - 1) depending on if the slope is positive or negative, respectively. It that case it increments pk by 2*dy - 2*dx and continues stepping through the line. The multiplications by two make the algorithm only use integer calculations, which makes it more efficient. 

&lt;div&gt;
            &lt;table style=&quot;width=100%&quot;&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part1.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Result Using Bresenham&#39;s Line Rasterizing Algorithm &lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
        

&lt;h2 align=&quot;middle&quot;&gt;Part 2:Rasterizing Single-Color Triangles&lt;/h2&gt;
&lt;p&gt;I ended up using two different methods to rasterize triangles. In the first method, I was breaking the triangles into &quot;top flat&quot; and &quot;bottom flat&quot; cases, and then stepping through the triangle and rendering it line by line. After part 5, I ended up switching to using barycentric coordinates to rasterize them. I needed to calculate barycentric coordinates to retrieve the correct color for each pixel, so it made sense to rasterize each pixel individually rather than rasterize a line at a time. Using barycentric coordinates to rasterize triangles also gave a cleaner result. 
					&lt;img src=&quot;../images/part_2_1.png&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt;Original Method: Note the lines extending off the claw and tail.&lt;/figcaption&gt;
                    &lt;img src=&quot;../images/part_2_2.png&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt;Barycentric Method&lt;/figcaption&gt;
            &lt;p&gt;In the first method I used to rasterize triangles, I broke them into three cases: 
            &lt;ul&gt;
            &lt;li&gt;Bottom Flat Triangles&lt;/li&gt;
            &lt;li&gt;Top Flat Triangles&lt;/li&gt;
            &lt;li&gt;Other&lt;/li&gt;&lt;/ul&gt;
        For the bottom flat triangles, I started by using my rasterize_line function to rasterize the bottom (flat) edge of the triangle, which was just the line between the two vertices with the lowest y coordinate. From there I calculated the inverse slope of each non-flat side of the triangle, and added that to the respective x coordinate. Then I incremented the y coordinate and plotted a line between the current x values and the y value.&lt;/p&gt;
        &lt;p&gt;Incrementing the x values and plotting the line: &lt;/p&gt;
        &lt;p align=&quot;middle&quot;&gt;
        &lt;pre align=&quot;middle&quot;&gt;current_x1 = current_x1 + m1^-1&lt;/pre&gt;
        &lt;pre align=&quot;middle&quot;&gt;current_x2 = current_x2 + m2^-1&lt;/pre&gt;
        &lt;pre align=&quot;middle&quot;&gt;rasterize_line(current_x1, y, current_x2, y)&lt;/pre&gt;&lt;/p&gt;
        &lt;p&gt; Where current_x1 is initialized to the x value of one of the bottom corners and current_x2 is the x value of the other bottom corner. Adding the inverse slope steps the x_values up along the edges of the triangle towards the top vertex. The subroutine to render top flat triangles was done similarly&lt;/p&gt; 
        &lt;p&gt; For the &quot;other&quot; case, I would simply divide the triangle into two seperate triangles: a bottom flat triangle and a top flat triangle. I generated a &quot;fourth&quot; vertex that was directly across from the &quot;middle&quot; vertex, the one with the middle y coordinate. &lt;/p&gt; 
        &lt;p align=&quot;middle&quot;&gt;&lt;pre align=&quot;middle&quot;&gt; x4 = x0 + ((y1 - y0)/(y2 - y0) * (x2 - x0))&lt;/pre&gt;&lt;/p&gt;
        &lt;p align=&quot;middle&quot;&gt;&lt;pre align=&quot;middle&quot;&gt;y4 = y1&lt;/pre&gt;&lt;/p&gt;
        &lt;p&gt; Where coordinates are sorted according to ascending y coordinates (so (x0, y0) has the smallest y coordinate and (x2, y2) has the highest y coordinate). Using this new fourth coordinate, I could use my prewritten subroutines to render the original triangle as two seperate triangles, one that was flat on top and the other which was flat on bottom. &lt;/p&gt; 
&lt;img src=&quot;../images/part2.png&quot; /&gt;
&lt;center&gt;Final Result: Rendered Triangles&lt;/center&gt;

&lt;h2 align=&quot;middle&quot;&gt; Part 3: Antialiasing triangles&lt;/h2&gt;
&lt;br /&gt;
&lt;p&gt; Part three was the most challenging for me! First I initialized the super sample buffer as a vector of unsigned chars, simiar to the frame rate buffer, except scaled up based on the sample rate. 
&lt;p align=&quot;middle&quot;&gt;&lt;pre align=&quot;middle&quot;&gt;total_sample_pts = width * height * sample_rate
&lt;br /&gt; 
superframebuffer.resize(total_sample_pts * 4)&lt;/pre&gt;&lt;/p&gt;

&lt;div&gt;
            &lt;table style=&quot;width=100%&quot;&gt;
                &lt;tr&gt;&lt;center&gt;
                    &lt;img src=&quot;../images/part_3_off_by_4.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt;Sample_Rate = 4. Image colors are off and image is repeating. The colors are off due to the indexing in red shown above. It should be: 
                    &lt;pre&gt; int index = (k*dimension) + &lt;font color=&quot;red&quot;&gt; &lt;font color=&quot;blue&quot;&gt;4 *&lt;/font&gt;(i + j)&lt;/font&gt;&lt;/pre&gt; Due to the supersamplebuffer storing rgba values for each pixel. &lt;/figcaption&gt;&lt;/center&gt;&lt;br /&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;
&lt;p&gt; The image is being repeated due to another indexing error when the pixels are drawn into the supersamplebuffer. Once the index was corrected, I got a new result:&lt;/p&gt;
&lt;div&gt;
	&lt;table style=&quot;width=100%&quot;&gt;
                &lt;tr align=&quot;left&quot;&gt;
                    &lt;img src=&quot;../images/part_3_indexbug.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt;&lt;br /&gt;Sample_Rate = 4. Image is scaled up larger than it should be and is lighter due to super sample pixel being blended with blank pixels.  &lt;/figcaption&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt; 
&lt;p&gt; The super sample pixel is:
        &lt;p&gt;&lt;pre align=&quot;middle&quot;&gt; 1/sqrt(sample_rate) &lt;/pre&gt;
            the size of a frame buffer pixel, so it&#39;s color blended with:
            &lt;pre align=&quot;middle&quot;&gt; (sqrt(sample_rate) - 1)/sqrt(sample_rate) &lt;/pre&gt; white pixels, giving the lighter, less opaque appearance.&lt;/p&gt;
        &lt;p&gt; I went through countless other iterations of indexing errors, many of which I can&#39;t recreate now. I ended up changing my resolve method to keep track of the x and y coordinate of the current frame buffer pixel. However, just now when trying to recreate another bug, I got my original resolve code to work. Still, my supersamples were getting lighter due to the blending error I described above. &lt;/p&gt; 
        &lt;p&gt; The biggest challenge I had was understanding how to actually anti-alias. At one point I was drawing to the super sample buffer correctly, my resolve method was working mostly correctly (the size of the images stayed consistent among different sample_rates), however there was no anti-aliasing. The jaggies looked the same whether the super_sample_rate was 1 or 16. &lt;/p&gt; 
        &lt;p&gt; 
            Did I need to scale the points by sqrt(sample_rate) in my supersample_point method? Did I need to scale up the triangle according to the sample rate? Or was it both? Between this and the indexing stuff, I was really confusing myself. Thankfully, Ren patiently talked through the idea with me until I understood: I needed to scale one or the other. Either the points or the triangle, but not both.
        &lt;/p&gt;  
        &lt;p&gt;  Scaling the size of the triangle felt more intuitive to me, so that is what I went with. In my &lt;font color=&quot;blue&quot;&gt; void DrawRend::rasterize_triangle() &lt;/font&gt; method, I scaled the input coordinates (x0,y0,...,x2,y2) up by a factor of sqrt(sample_rate). Then I repaired my &lt;font color=&quot;blue&quot;&gt; DrawRend::supersample_point(x, y) &lt;/font&gt; method so that it stored the true x and y coordinates, as opposed scaling them up as I did before. This allowed (sample_rate) more pixels to be rendered inside the triangle.
        &lt;/p&gt;
        &lt;p&gt; Then the resolve method downsampled the pixels back to the resolution of the framebuffer.So colors from a sqrt(sample_rate) X sqrt(sample_rate) square of pixels in the superframebuffer were averaged, and the resulting color was assigned to one corresponding pixel in the frame buffer, giving the final result.

                &lt;tr&gt;
                    &lt;td align=&quot;middle&quot;&gt;
                    &lt;img src=&quot;../images/part3_1.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt;Sample_Rate = 1&lt;/figcaption&gt;
                
                &lt;tr&gt;
                    &lt;td align=&quot;middle&quot;&gt;
                    &lt;img src=&quot;../images/part3_2.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt;Sample_Rate = 4&lt;/figcaption&gt;
                
                &lt;tr&gt;
                    &lt;td align=&quot;middle&quot;&gt;
                    &lt;img src=&quot;../images/part3_4.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt;Sample_Rate = 16&lt;/figcaption&gt;
                



&lt;h2 align=&quot;middle&quot;&gt;Part 4: Transforms&lt;/h2&gt;
&lt;p&gt;For part 4, I implemented the transform matrices as shown in the SVG spec. Then I created a new svg file, &quot;first.svg&quot;. I grabbed one of the stars shown in another example file and pasted it in my file. Then I made four identical stars and alternated their colors. Next, I put them all in a group that would translate them closer to the center of the page. Finally, I put each star in it&#39;s own group with a rotation applied. I incremented each rotation by .25 and added enough stars to make a ring of stars!&lt;/p&gt;

&lt;div&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/p4_2.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Ring of Stars &lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/p_4_3.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Ring of Stars Showing Zoom In, Translate GUI Features&lt;br /&gt; &lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/p_4_5.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Ring of Stars Showing Zoom Out, Translate GUI Features&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            
        &lt;/div&gt;


&lt;h2 align=&quot;middle&quot;&gt;Part 5: Barycentric coordinates&lt;/h2&gt;
&lt;p&gt; Barycentric coordinates give us a way to assign each vertex in a triangle an attribute, and then linearly interpolate those attributes to assign the appropriate value for the other pixels within the triangle. &lt;/p&gt;

&lt;div&gt;
            &lt;table style=&quot;width=100%&quot;&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_5_tri.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Triangle with a red vertex, blue vertex, and green vertex. The pixels between the vertices are assigned a color based on their barycentric coordinates.&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;

&lt;p&gt; In the example above, I will refer to the upper left vertex as &lt;font color=&quot;red&quot;&gt;R&lt;/font&gt;, the upper right vertex as &lt;font color=&quot;green&quot;&gt;G&lt;/font&gt;, and the lowest vertex as &lt;font color=&quot;blue&quot;&gt;B&lt;/font&gt;. All of the pixels between these vertices are assigned a color depending on where they are relative to &lt;font color=&quot;red&quot;&gt;R&lt;/font&gt;, &lt;font color=&quot;green&quot;&gt;G&lt;/font&gt;, and &lt;font color=&quot;blue&quot;&gt;B&lt;/font&gt;.
&lt;p&gt; Observe the pixels that lie on the edge between &lt;font color=&quot;red&quot;&gt;R&lt;/font&gt; and &lt;font color=&quot;blue&quot;&gt;B&lt;/font&gt;. The pixels closest to &lt;font color=&quot;red&quot;&gt;R&lt;/font&gt; are all red, and the pixels closest to &lt;font color=&quot;blue&quot;&gt;B&lt;/font&gt; are all blue. However, the pixels right in the middle of the edge are a purple shade, since they lie directly between the red and blue vertices. The pixel that lies exactly in the center of the two vertices gets:
	&lt;pre align=&quot;center&quot;&gt;.5*color(&lt;font color=&quot;blue&quot;&gt;B&lt;/font&gt;) + .5*color(&lt;font color=&quot;red&quot;&gt;R&lt;/font&gt;) + 0*color(&lt;font color=&quot;green&quot;&gt;G&lt;/font&gt;)&lt;/pre&gt;
The number that is multiplied by the color of each vertex is either alpha, beta, or gamma. Each one represents the relative distance from the pixel to one of the three triangle vertices. In the above example, alpha and beta are 0.5, since the pixel is halfway between the red and blue pixels. Gamma is zero since it is relatively far away. 
To implement this in my program, I first calculate the alpha, beta, and gamma barycentric coordinates using the coordinates passed into &lt;font color=&quot;blue&quot;&gt;&amp;lt;DrawRend::render_barycentric_triangle()&lt;/font&gt;. Then, these are passed to &lt;font color=&quot;blue&quot;&gt; ColorTri::color()&lt;/font&gt;. This method then multiplies alpha by the &quot;a&quot; vertex color, beta by the &quot;b&quot; vertex color, and gamma = (1 - alpha - beta) by the &quot;c&quot; vertex color. 

&lt;table style=&quot;width=100%&quot;&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_5.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Color Wheel Result.&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        


&lt;h2 align=&quot;middle&quot;&gt;Part 6: Pixel sampling for texture mapping&lt;/h2&gt;
&lt;h4&gt; Finding the UV Texture Coordinates &lt;/h4&gt;
&lt;p&gt; Implementing part 6 was very similar to part 5. The same way I used barycentric coordinates to interpolate the colors of three vertices of a triangle for the pixels in the triangle, I could map a coordinate inside a triangle to its corresponding uv texture coordinate. In &lt;font color=&quot;blue&quot;&gt; Color TexTri::color(Vector2D xy, Vector2D dx, Vector2D dy, SampleParams sp) &lt;/font&gt;, I multiply alpha by the &quot;a&quot; vertex&#39;s uv coordinate vector, beta by the &quot;b&quot; coordinate uv vector, and gamma by the &quot;c&quot; coordinate uv vector. &lt;/p&gt;
&lt;h4&gt; Retrieving the Color from the MipMap &lt;/h4&gt;
Once I had adjusted the uv vector, it is passed into &lt;font color=&quot;blue&quot;&gt;Texture::sample(const SampleParams &amp;amp;sp)&lt;/font&gt;, which then calls the appropriate sampling method according to the sp.psm parameter. The sampling method retreives the level 0 mip map (for this portion). The uv coordinates are between 0 and 1, so the sampling method then scales them up to match the proportions of the mipmap. 
&lt;pre align=&quot;center&quot;&gt; x = uv.x * mipmap.width &lt;br /&gt; y = uv.y * mipmap*height &lt;/pre&gt; Then, the color of the pixel is retrieved from the mipmap. 
&lt;pre align=&quot;center&quot;&gt;return MipMapPixelColor(x, y, level)&lt;/pre&gt;
&lt;h4&gt; Nearest vs Bilinear Sampling &lt;/h4&gt;
The nearest level sampling method simply returns the color of the pixel as above. The Bilinear method returns an interpolation of the four nearest uv coordinates. I used the algorithm in the book to implement bilinear sampling. The difference between nearest and bilinear sampling is the most apparent in the map sample images, which have distinct thin vertical lines through them. &lt;/p&gt;

&lt;div&gt;
            &lt;table style=&quot;width=100%&quot;&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_nearest_1.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Nearest Level Pixel Sampling, sample_rate = 1. &lt;br /&gt;Jaggies! Blegh!&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_bilinear_1.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Bilinear Pixel Sampling, sample_rate = 1 &lt;br /&gt;
               		SoooOossosoSo smooth &amp;lt;3 &lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
        
Even with a high sample rate, the difference between the two methods is apparent on these images. &lt;br /&gt;&lt;br /&gt;
&lt;div&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_nearest_16.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Nearest Level Pixel Sampling, sample_rate = 16 &lt;br /&gt;
                    	Gross! Blurry Jaggies!&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_bilinear_16.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Bilinear Pixel Sampling, sample_rate = 16 &lt;br /&gt; 
                   Ridiculously good looking.&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            
        &lt;/div&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p&gt; 
	However, without these distinct lines, the effect is much less noticeable. In the campanille image, I actually prefer the nearest sampling method. The features of the image seem slightly better with the nearest sampling.  &lt;/p&gt;
&lt;div&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_camp_nearest.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Nearest Level Pixel Sampling, sample_rate = 16 &lt;br /&gt;
                    	Looks pretty nice.&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part6_camp_bi.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Bilinear Pixel Sampling, sample_rate = 16 &lt;br /&gt; 
                    &lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            
        &lt;/div&gt;
&lt;p&gt; 
	Initially when retrieving the mip map colors, I had a bug because I wasn&#39;t dividing my colors by 255. Thanks to piazza, I knew I had to divide them by 255 since the color was expecting a float between 0 and 1. However at first that was just giving me black images. Then I realized I literally had to divide it by &quot;255.&quot; to prevent a precision error. 
	&lt;div&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_1.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Weird Colors&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_5.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Looks Like Sprinkles!&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_6_4.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Corner Sprinkles&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            
        &lt;/div&gt;


&lt;h2 align=&quot;middle&quot;&gt;Part 7: Level sampling with mipmaps for texture mapping&lt;/h2&gt;
&lt;p&gt;In the final part, I implemented the &quot;get level&quot; method using the math described in the textbook. This allows the texture sampling to grab different mip maps for each pixel, depending on which is most appropriate. Sometimes the effects are desirable, and other times it ends up blurring the image. &lt;/p&gt;
&lt;p&gt; In trilinear sampling, the color from the getLevel() mipMap and the color from the adjacent level are blended to give the resulting color. 
&lt;div&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_7_lzero_pnear.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Level Zero, Nearest Sampling&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_7_lzero_plin.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Level Zero, Linear Sampling &lt;br /&gt; &lt;/figcaption&gt;&lt;br /&gt;
                    &lt;p&gt; I thought the above combination, Level Zero with Linear Sampling, gave the best result. It is the only one that eliminates the Jaggies in the &quot;Maleficent&quot; chrome text. &lt;/p&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_7_lnear_plin.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Nearest Level, Linear Sampling&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_7_lnear_pnear.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Nearest Level, Nearest Sampling&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            
        &lt;/div&gt;
&lt;p&gt; For closer images, there was visable blurring when using the trilinear sampling method. &lt;/p&gt;
&lt;div&gt;&lt;tr&gt;
                    &lt;img src=&quot;../images/part_7_llin_maleficent.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Trilinear Sampling &lt;br /&gt; Observe the blurring in Maleficent&#39;s face. &lt;/figcaption&gt;&lt;br /&gt;
                    
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_7_llin_maleficent2.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Trilinear Sampling&lt;/figcaption&gt;&lt;br /&gt;
                    
                &lt;/tr&gt;
             	&lt;tr&gt;
                    &lt;img src=&quot;../images/part7_lnear_pnear_2.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Nearest Level, Nearest Sampling&lt;br /&gt;I felt this was the best result for this image. &lt;/figcaption&gt;&lt;br /&gt;
                    
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;img src=&quot;../images/part_7_plin_lzero.png&quot; width=&quot;800px&quot; /&gt;
                    &lt;figcaption align=&quot;middle&quot;&gt; Level Zero, Linear Sampling &lt;br /&gt; The jaggies are less apparent in the writing, but Maleficent is a little more blurry.&lt;/figcaption&gt;&lt;br /&gt;
                &lt;/tr&gt;
            
        &lt;/div&gt;

            



&lt;/p&gt;&lt;/p&gt;&lt;/table&gt;&lt;/div&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;&lt;/p&gt;&lt;/table&gt;&lt;/div&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jan 2016 00:00:00 -0800</pubDate>
        <link>http://kadie16.github.io/rasterizester/</link>
        <guid isPermaLink="true">http://kadie16.github.io/rasterizester/</guid>
        
        
        <category>featured</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>3D Viewer</title>
        <description>&lt;center&gt;&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/WWfwJuYsd7c&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;A demo of my completed 3D Viewer project, written in C++. I also used OpenGL, GLSL, CGAL, and QT. I implemented user interactions including rotation, translation, and zoom by manipulating the viewing volume. The program also supports generation of 3-D volume mesh from surface mesh data.&lt;/p&gt;

&lt;p&gt;Just to clarify, my project is the viewing program itself! Not the models you see. I got the models I used to test my program from the UC Berkeley Computer Graphics group.&lt;/p&gt;

&lt;p&gt;If you are interested in learning about the progression of my work on this project, check out these posts: &lt;br /&gt;
- &lt;a href=&quot;http://kadie.me/working-I-swear/&quot;&gt;I’m working, I swear!&lt;/a&gt; &lt;br /&gt;
- &lt;a href=&quot;http://kadie.me/project-update-short/&quot;&gt;Work in Progress&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Aug 2015 00:00:00 -0700</pubDate>
        <link>http://kadie16.github.io/3dviewer/</link>
        <guid isPermaLink="true">http://kadie16.github.io/3dviewer/</guid>
        
        <category>C++</category>
        
        
        <category>projects</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>3D Viewer</title>
        <description>&lt;center&gt;&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/WWfwJuYsd7c&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;A demo of my completed 3D Viewer project, written in C++. I also used OpenGL, GLSL, CGAL, and QT. I implemented user interactions including rotation, translation, and zoom by manipulating the viewing volume. The program also supports generation of 3-D volume mesh from surface mesh data.&lt;/p&gt;

&lt;p&gt;Just to clarify, my project is the viewing program itself! Not the models you see. I got the models I used to test my program from the UC Berkeley Computer Graphics group.&lt;/p&gt;

&lt;p&gt;If you are interested in learning about the progression of my work on this project, check out these posts: &lt;br /&gt;
- &lt;a href=&quot;http://kadie.me/working-I-swear/&quot;&gt;I’m working, I swear!&lt;/a&gt; &lt;br /&gt;
- &lt;a href=&quot;http://kadie.me/project-update-short/&quot;&gt;Work in Progress&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Aug 2015 00:00:00 -0700</pubDate>
        <link>http://kadie16.github.io/3dviewer/</link>
        <guid isPermaLink="true">http://kadie16.github.io/3dviewer/</guid>
        
        <category>C++</category>
        
        
        <category>featured</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>Gitlet &amp; BearGit</title>
        <description>&lt;h2 id=&quot;gitlet&quot;&gt;Gitlet&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;My&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;own&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;which&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mimics&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;git&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;written&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Java&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* I implemented git commands including &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* initialize &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* add, commit, remove&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* log, global log&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* find, status&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* checkout&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* branch, remove branch&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* reset, merge, and rebase. */&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;designed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;own&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;API&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://octodex.github.com/images/carlostocat.gif&quot; alt=&quot;gitlet&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;beargit&quot;&gt;Beargit&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;Another&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;git&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mimic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;written&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;Every&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;must&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contain&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;THIS IS BEAR TERRITORY!&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Beargit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; 
&lt;span class=&quot;cm&quot;&gt;/* My partner and I implemented &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* status, log&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* rm&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* commit &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* branch &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* checkout&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;* reset, merge. */&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;We&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;also&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wrote&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cunit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tests&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Octocat photos courtesy of &lt;a href=&quot;https://octodex.github.com/&quot;&gt;octodex&lt;/a&gt; :)&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Aug 2015 00:00:00 -0700</pubDate>
        <link>http://kadie16.github.io/gitlet/</link>
        <guid isPermaLink="true">http://kadie16.github.io/gitlet/</guid>
        
        <category>Java</category>
        
        
        <category>projects</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>Work in Progress</title>
        <description>&lt;center&gt;&lt;iframe width=&quot;604.8&quot; height=&quot;453.6&quot; src=&quot;https://www.youtube.com/embed/cjPib3gQU-k&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;A Demonstration of my Project thus far&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;My project is a C++ program that reads in data describing 3D models, in .obj file format, and renders and lights the models with OpenGL. Since my last post, I have implemented some user interactions and use of the CGAL data structure. The models I use to test my program came from the &lt;a href=&quot;http://graphics.berkeley.edu&quot;&gt;UC Berkeley Computer Graphics&lt;/a&gt; website :)&lt;/p&gt;

&lt;h2 id=&quot;latest-changes&quot;&gt;Latest Changes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Automatically find and fit model.&lt;/li&gt;
  &lt;li&gt;Maintain aspect ratio on window resize.&lt;/li&gt;
  &lt;li&gt;Select Color.&lt;/li&gt;
  &lt;li&gt;Shading based on vertex normal vectors.&lt;/li&gt;
  &lt;li&gt;Rotation by mouse drag.&lt;/li&gt;
  &lt;li&gt;Zoom by right click mouse drag.&lt;/li&gt;
  &lt;li&gt;Option to move model by mouse drag.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;find-and-fit&quot;&gt;Find and Fit&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveToCenter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fitModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;maxCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;maxCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, whenever a new .obj file is selected, the “camera” automatically centers the model and makes it fit on the screen. I say “camera” because there is no actual camera in OpenGL. Instead, you manipulate the view by applying matrix transformations to the modelview and projection matrices. More on that later. I wrote a “camera” class, which handles these transformations.&lt;/p&gt;

&lt;h3 id=&quot;aspect-ratio&quot;&gt;Aspect Ratio&lt;/h3&gt;
&lt;p&gt;I think this is probably the least noticeable new feature, but it was one of the bigger challenges. If you watch closely, you can see that when I resize the window in the video, the cube retains its shape. In otherwords, it doesn’t turn into a rectangle if the viewer isn’t perfectly square. You might also notice that the angel is more slender than before.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/angel7.png&quot; alt=&quot;Angel Aspect Before&quot; /&gt; &lt;em&gt;&lt;center&gt;Squished angel&lt;/center&gt;&lt;/em&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/angel8.png&quot; alt=&quot;Angel Aspect After&quot; /&gt; &lt;em&gt;&lt;center&gt;Angel with corrected aspect ratio&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adjustAspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Modify the Projection Matrix */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_PROJECTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Start from a &amp;#39;clean slate&amp;#39; */&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;glLoadIdentity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Calculate Aspect Ratio */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Adjust Accordingly */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;leftAdjust&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rightAdjust&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glOrtho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftAdjust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rightAdjust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;near&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;color-picking&quot;&gt;Color Picking&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/humanoid1.png&quot; alt=&quot;humanoid color pick&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To me this feature seems more impressive than the constant aspect ratio, but it took about five minutes to implement. Thanks to QT, color picking boiled down to two lines of code.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MainWindow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_toolButton_clicked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QColor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QColorDialog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ui&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grabColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;ui is the User Interface, widget is the part of the ui that displays the model&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ok, I had to write grabColor too, so maybe 5 lines. Still. I actually threw this feature in because I needed a break from some other issue I was stuck on.&lt;/p&gt;

&lt;h3 id=&quot;vertex-shading&quot;&gt;Vertex Shading&lt;/h3&gt;

&lt;p&gt;In my last post, I mentioned that every vertex needs a normal vector so openGL knows how to shade the model. At that time, I was just computing the normal for each face and lighting all of the vertices in that face uniformly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/shading1.png&quot; alt=&quot;Before and after cube picture&quot; /&gt; &lt;em&gt;&lt;center&gt;Before and After per-vertex shading&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, the normal for each vertex is assigned to be the &lt;em&gt;average&lt;/em&gt; of the normals of all of the faces it belongs to. So the vertices on the corners of the cube are assigned a normal equal to the average of the normal vectors of the three faces that meet at that corner. The vertices on the edge of two faces get the average of the two normal vectors of those faces. The vertices in the middle of the face just get the normal that belongs to that face. OpenGL then interpolates in between the vertices to produce the smooth gradient you see.&lt;/p&gt;

&lt;h3 id=&quot;user-controls&quot;&gt;User Controls&lt;/h3&gt;

&lt;h4 id=&quot;making-it-feel-natural&quot;&gt;Making it “feel” natural&lt;/h4&gt;
&lt;p&gt;I expected understanding the openGL calls to be challenging, but I didn’t anticipate the challenge of making the controls intuitive. I guess this speaks to the idea that the best computer graphics go unnoticed.&lt;/p&gt;

&lt;p&gt;The user controls are simulated by a series of repaints. Actually the model is being redrawn constantly, but without adjustments to the modelview or projection matrix, it is just drawn exactly the same. So my goal is to animate, or redraw, the model so the user feels like they are actually touching and manipulating the model with their mouse.&lt;/p&gt;

&lt;h4 id=&quot;rotation&quot;&gt;Rotation&lt;/h4&gt;
&lt;p&gt;Getting the model to rotate wasn’t hard. I could just use glRotatef to do that.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;glRotatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;angle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;&lt;/center&gt;&lt;/em&gt;
Getting the model to rotate according to mouse drag wasn’t a big deal either. All I had to do was set the parameters in glRotatef based on the change in position of the mouse. The hard part was getting the model to rotate in a way that felt &lt;em&gt;natural&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The first problem is glRotatef rotates the model around the origin, the point (0,0,0). This gives the appearance that the model was orbiting about an arbitrary point in space. Not what I want. I want the model to rotate about it’s center. That way it stays where it is and just spins around.&lt;/p&gt;

&lt;p&gt;There is a clever trick to accomplish this. Since glRotatef rotates about the origin, you can just move whatever point you want to rotate about to the origin, apply the rotation, and then move the object back to where it was. Imagine I pick up the model, move it’s center to the origin, rotate it, and move it back to it’s original point in space.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* Move center to origin */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Rotate */&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;glRotatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;angle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Apply reverse translation to move center back to where it was */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Pretty neat trick! But still, I am left with a model that is rotating in crazy unpredictable patterns.&lt;/p&gt;

&lt;iframe width=&quot;604.8&quot; height=&quot;453.6&quot; src=&quot;https://www.youtube.com/embed/ebHibD78bCI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;?????????&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The rotations seem accurate at the beginning of the demo, but soon deviate from what is expected. You can see that the effect of dragging the mouse in one direction (like left to right) is inconsistent as time goes on.&lt;/p&gt;

&lt;p&gt;This is because the rotations are accumulating.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Desired Effect&lt;/strong&gt;: &lt;br /&gt;
0.) Start Position. &lt;br /&gt;
1.) Apply rotation A to position at 0. &lt;br /&gt;
2.) Apply rotation &lt;strong&gt;B&lt;/strong&gt; to position at 1. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We want each mouse drag to produce a new, independent rotation. So when I drag the mouse from left to right, the model spins right, regardless of the rotations I performed previously.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Actual Effect&lt;/strong&gt;: &lt;br /&gt;
0.) Start Position. &lt;br /&gt;
1.) Apply rotation A to position at 0. &lt;br /&gt;
2.) Apply rotation &lt;strong&gt;(A + B)&lt;/strong&gt; to position at 1. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As is, the rotations are adding on top of eachother. So when I drag the mouse left to right, the model spins according to the sum of the prior rotation and the desired left to right rotation. Confusing right?!?!?!?!&lt;/p&gt;

&lt;h4 id=&quot;opengl-matrix-stack&quot;&gt;OpenGL Matrix Stack&lt;/h4&gt;
&lt;p&gt;Here, the openGL matrix stack comes in. Here is the deal: In order to rotate my model, I am manipulating the Model View Matrix. But openGL actually maintains a “stack” of Model View Matrices for me to work with. If I want to save my current matrix, I can “push” it to the stack. Then, I can change the matrix however I want. When I decide that I want to go back to that matrix I pushed earlier, I can “pop” the matrix and I will get the next one on the stack. More confusion, no?&lt;/p&gt;

&lt;p&gt;Let’s pretend that coloring is a matrix operation. So I start out with a regular white model view matrix. I call glPushMatrix(). Then I paint the matrix yellow.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* My matrix is white */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPushMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Saving white matrix for later. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Yellow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a yellow matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Next, I decide I want a red matrix. If I just start using red paint to my yellow matrix, I am going to end up with an orange matrix. So, first I call glPopMatrix(). Now I get the white matrix back, paint it red, and I have a true red matrix.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* My matrix is yellow */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Getting the white matrix back. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPushMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Saving red matrix for later.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a red matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, I call glPushMatrix() again. I want to turn the matrix purple this time. So I paint this matrix blue, and get a purple matrix. Now I want a green matrix! But I don’t want to slather green paint on a purple thing.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Now my matrix is purple! */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a purple matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Got my red matrix back. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Got my white matrix back. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a green matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;back-to-rotation&quot;&gt;Back to Rotation&lt;/h4&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;QQuaternion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLWidget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drag2Rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Define Axis of Rotation */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;magnitude&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Update Rotation Quaternion */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QQuaternion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QQuaternion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromAxisAndAngle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;magnitude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; I keep track of the current Quaternion (represents the current rotation) by multiplying the new, applied rotation by the former rotation &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;glPushMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Saves state before rotation */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;QMatrix4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotationMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Begins&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Like&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* Here I rotate by the Quaternion, which holds the current rotation */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rotationMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_MODELVIEW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* Translate so rotation occurs about model center */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glMultMatrixf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drawMe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Reverts to state before rotation */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; This way, the next time the model is drawn, the rotation is applied to the original, &quot;white&quot;, matrix. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;zoom&quot;&gt;Zoom&lt;/h4&gt;
&lt;p&gt;My first idea was to use glScalef on the Model View Matrix to zoom.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MainWindow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_toolButton_clicked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_MODELVIEW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Specifies which matrix will be scaled&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glScalef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; Calling glScalef(0.5,0.5,0.5) would uniformly scale the Model View Matrix down 50%&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That isn’t quite right. Here I am actually changing the size of the model, rather than getting closer or further. This is kind of like the desired effect, but if I get too close holes start appearing in my models. By scaling the Model View Matrix, the model can get so big that parts of it would lie outside the clipping planes.&lt;/p&gt;

&lt;iframe width=&quot;604.8&quot; height=&quot;453.6&quot; src=&quot;https://www.youtube.com/embed/crWdEMgDwNE&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Instead of adjusting the Model View Matrix, I need to adjust the Projection Matrix. Doing so changes the way I view the “world”, as opposed to changing the model itself.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setZoom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_PROJECTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glLoadIdentity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Make sure zoom isn&amp;#39;t applied to the previous state&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glOrtho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leftAdjust&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rightAdjust&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;near&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;That’s it for now :) My next post will show my final project!&lt;/p&gt;

</description>
        <pubDate>Sat, 01 Aug 2015 00:00:00 -0700</pubDate>
        <link>http://kadie16.github.io/project-update-short/</link>
        <guid isPermaLink="true">http://kadie16.github.io/project-update-short/</guid>
        
        <category>C++</category>
        
        <category>Work</category>
        
        <category>Project</category>
        
        <category>OpenGL</category>
        
        <category>Computer</category>
        
        <category>Graphics</category>
        
        <category>QT</category>
        
        <category>CGAL</category>
        
        
        <category>abroad</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>Work in Progress</title>
        <description>&lt;center&gt;&lt;iframe width=&quot;604.8&quot; height=&quot;453.6&quot; src=&quot;https://www.youtube.com/embed/cjPib3gQU-k&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;A Demonstration of my Project thus far&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;My project is a C++ program that reads in data describing 3D models, in .obj file format, and renders and lights the models with OpenGL. Since my last post, I have implemented some user interactions and use of the CGAL data structure. The models I use to test my program came from the &lt;a href=&quot;http://graphics.berkeley.edu&quot;&gt;UC Berkeley Computer Graphics&lt;/a&gt; website :)&lt;/p&gt;

&lt;h2 id=&quot;latest-changes&quot;&gt;Latest Changes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Automatically find and fit model.&lt;/li&gt;
  &lt;li&gt;Maintain aspect ratio on window resize.&lt;/li&gt;
  &lt;li&gt;Select Color.&lt;/li&gt;
  &lt;li&gt;Shading based on vertex normal vectors.&lt;/li&gt;
  &lt;li&gt;Rotation by mouse drag.&lt;/li&gt;
  &lt;li&gt;Zoom by right click mouse drag.&lt;/li&gt;
  &lt;li&gt;Option to move model by mouse drag.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;find-and-fit&quot;&gt;Find and Fit&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveToCenter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fitModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;maxCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;maxCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCoords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, whenever a new .obj file is selected, the “camera” automatically centers the model and makes it fit on the screen. I say “camera” because there is no actual camera in OpenGL. Instead, you manipulate the view by applying matrix transformations to the modelview and projection matrices. More on that later. I wrote a “camera” class, which handles these transformations.&lt;/p&gt;

&lt;h3 id=&quot;aspect-ratio&quot;&gt;Aspect Ratio&lt;/h3&gt;
&lt;p&gt;I think this is probably the least noticeable new feature, but it was one of the bigger challenges. If you watch closely, you can see that when I resize the window in the video, the cube retains its shape. In otherwords, it doesn’t turn into a rectangle if the viewer isn’t perfectly square. You might also notice that the angel is more slender than before.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/angel7.png&quot; alt=&quot;Angel Aspect Before&quot; /&gt; &lt;em&gt;&lt;center&gt;Squished angel&lt;/center&gt;&lt;/em&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/angel8.png&quot; alt=&quot;Angel Aspect After&quot; /&gt; &lt;em&gt;&lt;center&gt;Angel with corrected aspect ratio&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adjustAspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Modify the Projection Matrix */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_PROJECTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Start from a &amp;#39;clean slate&amp;#39; */&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;glLoadIdentity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Calculate Aspect Ratio */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Adjust Accordingly */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;leftAdjust&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rightAdjust&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAspect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glOrtho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftAdjust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rightAdjust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;near&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;color-picking&quot;&gt;Color Picking&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/humanoid1.png&quot; alt=&quot;humanoid color pick&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To me this feature seems more impressive than the constant aspect ratio, but it took about five minutes to implement. Thanks to QT, color picking boiled down to two lines of code.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MainWindow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_toolButton_clicked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QColor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QColorDialog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ui&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grabColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;ui is the User Interface, widget is the part of the ui that displays the model&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ok, I had to write grabColor too, so maybe 5 lines. Still. I actually threw this feature in because I needed a break from some other issue I was stuck on.&lt;/p&gt;

&lt;h3 id=&quot;vertex-shading&quot;&gt;Vertex Shading&lt;/h3&gt;

&lt;p&gt;In my last post, I mentioned that every vertex needs a normal vector so openGL knows how to shade the model. At that time, I was just computing the normal for each face and lighting all of the vertices in that face uniformly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/progress/shading1.png&quot; alt=&quot;Before and after cube picture&quot; /&gt; &lt;em&gt;&lt;center&gt;Before and After per-vertex shading&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, the normal for each vertex is assigned to be the &lt;em&gt;average&lt;/em&gt; of the normals of all of the faces it belongs to. So the vertices on the corners of the cube are assigned a normal equal to the average of the normal vectors of the three faces that meet at that corner. The vertices on the edge of two faces get the average of the two normal vectors of those faces. The vertices in the middle of the face just get the normal that belongs to that face. OpenGL then interpolates in between the vertices to produce the smooth gradient you see.&lt;/p&gt;

&lt;h3 id=&quot;user-controls&quot;&gt;User Controls&lt;/h3&gt;

&lt;h4 id=&quot;making-it-feel-natural&quot;&gt;Making it “feel” natural&lt;/h4&gt;
&lt;p&gt;I expected understanding the openGL calls to be challenging, but I didn’t anticipate the challenge of making the controls intuitive. I guess this speaks to the idea that the best computer graphics go unnoticed.&lt;/p&gt;

&lt;p&gt;The user controls are simulated by a series of repaints. Actually the model is being redrawn constantly, but without adjustments to the modelview or projection matrix, it is just drawn exactly the same. So my goal is to animate, or redraw, the model so the user feels like they are actually touching and manipulating the model with their mouse.&lt;/p&gt;

&lt;h4 id=&quot;rotation&quot;&gt;Rotation&lt;/h4&gt;
&lt;p&gt;Getting the model to rotate wasn’t hard. I could just use glRotatef to do that.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;glRotatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;angle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;&lt;/center&gt;&lt;/em&gt;
Getting the model to rotate according to mouse drag wasn’t a big deal either. All I had to do was set the parameters in glRotatef based on the change in position of the mouse. The hard part was getting the model to rotate in a way that felt &lt;em&gt;natural&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The first problem is glRotatef rotates the model around the origin, the point (0,0,0). This gives the appearance that the model was orbiting about an arbitrary point in space. Not what I want. I want the model to rotate about it’s center. That way it stays where it is and just spins around.&lt;/p&gt;

&lt;p&gt;There is a clever trick to accomplish this. Since glRotatef rotates about the origin, you can just move whatever point you want to rotate about to the origin, apply the rotation, and then move the object back to where it was. Imagine I pick up the model, move it’s center to the origin, rotate it, and move it back to it’s original point in space.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* Move center to origin */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Rotate */&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;glRotatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;angle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLfloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Apply reverse translation to move center back to where it was */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Pretty neat trick! But still, I am left with a model that is rotating in crazy unpredictable patterns.&lt;/p&gt;

&lt;iframe width=&quot;604.8&quot; height=&quot;453.6&quot; src=&quot;https://www.youtube.com/embed/ebHibD78bCI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;?????????&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The rotations seem accurate at the beginning of the demo, but soon deviate from what is expected. You can see that the effect of dragging the mouse in one direction (like left to right) is inconsistent as time goes on.&lt;/p&gt;

&lt;p&gt;This is because the rotations are accumulating.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Desired Effect&lt;/strong&gt;: &lt;br /&gt;
0.) Start Position. &lt;br /&gt;
1.) Apply rotation A to position at 0. &lt;br /&gt;
2.) Apply rotation &lt;strong&gt;B&lt;/strong&gt; to position at 1. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We want each mouse drag to produce a new, independent rotation. So when I drag the mouse from left to right, the model spins right, regardless of the rotations I performed previously.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Actual Effect&lt;/strong&gt;: &lt;br /&gt;
0.) Start Position. &lt;br /&gt;
1.) Apply rotation A to position at 0. &lt;br /&gt;
2.) Apply rotation &lt;strong&gt;(A + B)&lt;/strong&gt; to position at 1. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As is, the rotations are adding on top of eachother. So when I drag the mouse left to right, the model spins according to the sum of the prior rotation and the desired left to right rotation. Confusing right?!?!?!?!&lt;/p&gt;

&lt;h4 id=&quot;opengl-matrix-stack&quot;&gt;OpenGL Matrix Stack&lt;/h4&gt;
&lt;p&gt;Here, the openGL matrix stack comes in. Here is the deal: In order to rotate my model, I am manipulating the Model View Matrix. But openGL actually maintains a “stack” of Model View Matrices for me to work with. If I want to save my current matrix, I can “push” it to the stack. Then, I can change the matrix however I want. When I decide that I want to go back to that matrix I pushed earlier, I can “pop” the matrix and I will get the next one on the stack. More confusion, no?&lt;/p&gt;

&lt;p&gt;Let’s pretend that coloring is a matrix operation. So I start out with a regular white model view matrix. I call glPushMatrix(). Then I paint the matrix yellow.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* My matrix is white */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPushMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Saving white matrix for later. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Yellow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a yellow matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Next, I decide I want a red matrix. If I just start using red paint to my yellow matrix, I am going to end up with an orange matrix. So, first I call glPopMatrix(). Now I get the white matrix back, paint it red, and I have a true red matrix.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* My matrix is yellow */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Getting the white matrix back. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPushMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Saving red matrix for later.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a red matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, I call glPushMatrix() again. I want to turn the matrix purple this time. So I paint this matrix blue, and get a purple matrix. Now I want a green matrix! But I don’t want to slather green paint on a purple thing.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Now my matrix is purple! */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a purple matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Got my red matrix back. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Got my white matrix back. &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;applyPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;drawMyMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; displays a green matrix &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;back-to-rotation&quot;&gt;Back to Rotation&lt;/h4&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;QQuaternion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLWidget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drag2Rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Define Axis of Rotation */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;magnitude&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* Update Rotation Quaternion */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QQuaternion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QQuaternion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromAxisAndAngle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axisOfRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;magnitude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; I keep track of the current Quaternion (represents the current rotation) by multiplying the new, applied rotation by the former rotation &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;glPushMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Saves state before rotation */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;QMatrix4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotationMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Begins&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Like&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* Here I rotate by the Quaternion, which holds the current rotation */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rotationMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_MODELVIEW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* Translate so rotation occurs about model center */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glMultMatrixf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glTranslatef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drawMe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;glPopMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Reverts to state before rotation */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; This way, the next time the model is drawn, the rotation is applied to the original, &quot;white&quot;, matrix. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;zoom&quot;&gt;Zoom&lt;/h4&gt;
&lt;p&gt;My first idea was to use glScalef on the Model View Matrix to zoom.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MainWindow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_toolButton_clicked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_MODELVIEW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Specifies which matrix will be scaled&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glScalef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt; Calling glScalef(0.5,0.5,0.5) would uniformly scale the Model View Matrix down 50%&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That isn’t quite right. Here I am actually changing the size of the model, rather than getting closer or further. This is kind of like the desired effect, but if I get too close holes start appearing in my models. By scaling the Model View Matrix, the model can get so big that parts of it would lie outside the clipping planes.&lt;/p&gt;

&lt;iframe width=&quot;604.8&quot; height=&quot;453.6&quot; src=&quot;https://www.youtube.com/embed/crWdEMgDwNE&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Instead of adjusting the Model View Matrix, I need to adjust the Projection Matrix. Doing so changes the way I view the “world”, as opposed to changing the model itself.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setZoom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glMatrixMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_PROJECTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glLoadIdentity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Make sure zoom isn&amp;#39;t applied to the previous state&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glOrtho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leftAdjust&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rightAdjust&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zoomF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;near&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;That’s it for now :) My next post will show my final project!&lt;/p&gt;

</description>
        <pubDate>Sat, 01 Aug 2015 00:00:00 -0700</pubDate>
        <link>http://kadie16.github.io/project-update-short/</link>
        <guid isPermaLink="true">http://kadie16.github.io/project-update-short/</guid>
        
        <category>C++</category>
        
        <category>Work</category>
        
        <category>Project</category>
        
        <category>OpenGL</category>
        
        <category>Computer</category>
        
        <category>Graphics</category>
        
        <category>QT</category>
        
        <category>CGAL</category>
        
        
        <category>projects</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>LAOS</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/piggyBack.jpg&quot; alt=&quot;tuktuk&quot; /&gt; &lt;em&gt;&lt;center&gt;&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;going-to-vang-vieng&quot;&gt;Going to Vang Vieng&lt;/h2&gt;

&lt;p&gt;I really can’t do justice to my Laos trip by writing about it, but I’ll try. I got into Vientiane pretty late at night on July 3rd and took a taxi to my hotel. Navigating Laos was a little more difficult than Thailand. The language barrier was more prominent, and the infrastructure fell anywhere between well kept buildings and mud huts. I needed to travel about four hours from Vientiane to Vang Vieng to meet Sarah and Ryan. In the morning, I asked the concierge at my hotel for a cab to the bus station. The staff insisted I take a tuk-tuk to save money. Lol. One of the hotel employees helped me flag one down on the street, with two young buddhist monks were occupying the back. They couldn’t have been older than 10 or 12. They directed their eyes away from me, but politely shifted over to make room. After a few blocks, the tuk tuk driver ordered them out and gestured to this random truck with a bunch of people stuffed inside. They hopped out and into the truck, and the tuk-tuk driver took a U-turn to proceed down a rocky, unpaved road. He swerved past most of the potholes but a few times I thought I was about to fly out of the tuk-tuk lol. I’m pretty sure I got ripped off because the ride cost just as much as my cab the night before, but I didn’t feel like complaining because it was still less than $5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/tuktukSelfie.jpg&quot; alt=&quot;tuktuk&quot; /&gt; &lt;em&gt;&lt;center&gt;Me in my overpriced Tuk-Tuk&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I didn’t really know what to expect when I got to the bus station. Thankfully right when I arrived, a man pointed to me and asked “Vang Vieng?”. I said yes and he led me over to a “mini bus”. I was sharing the mini bus with a bunch of teenage boys who were trying to covertly photograph me by pretending they were taking selfies. It was very obvious, so I just stuck my tongue out or smiled when I caught them. We stopped a couple times to squeeze in other passengers along the way,  and once to use the restroom. Everyone gathered to have a cigarette when we stopped. I stood with them and had a popsicle.&lt;/p&gt;

&lt;p&gt;Just when I was beginning to wonder how much longer I’d be stuck in the mini bus, I arrived in Vang Vieng. I paid the gave the mini bus driver $5 and hopped in another tuk-tuk to meet Sarah and Ryan.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/tuktuk.jpg&quot; alt=&quot;tuktuk&quot; /&gt; &lt;em&gt;&lt;center&gt;Pulling into the driveway to Sarah and Ryan&#39;s hotel&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We had some lunch at an Irish bar, and then rented tubes so we could go float down the river :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/shoes.jpg&quot; alt=&quot;shoes&quot; /&gt; &lt;em&gt;&lt;center&gt;We didn&#39;t leave our shoes lol&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-last-bar&quot;&gt;The Last Bar&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/crib2.jpg&quot; alt=&quot;river&quot; /&gt; &lt;em&gt;&lt;center&gt;&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I wasn’t expecting anyone in Laos to care about the 4th of July, but when we reached the first bar on the river there were a couple other Americans and plenty of people with red white and blue body paint. I asked one of the guys for a headband and he was kind enough to give me and Sarah his last ones :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/noRyan.jpg&quot; alt=&quot;tuktuk&quot; /&gt; &lt;em&gt;&lt;center&gt;&quot;Sorry Ryan, you can&#39;t be in the picture because you don&#39;t have a headband&quot;&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ryan and Sarah and I had been looking for friendship bracelets since our first rendezvous in Phi Phi. We resolved to look for some that day because I might not see them in Asia again. It turned out we didn’t even have to, because one of the bartenders gave us friendship bracelets shortly after we started tubing :) It was pretty neat. After hanging out at the second bar for a while, we continued tubing down the river. We didn’t get very far, since the next bar was always roughly 50 yards away from the previous one. Every time we would approach another one, one of the people working there would cast their line (a waterbottle tied to a rope) and reel us in.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/fished4.jpg&quot; alt=&quot;tuktuk&quot; /&gt; &lt;em&gt;&lt;center&gt;He caught me :D &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/scenery.jpg&quot; alt=&quot;scenery&quot; /&gt; &lt;em&gt;&lt;center&gt; View at my favorite bar&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The “bars” were really just makeshift porches on the side of the river, but they were sick. One of my favorites was up on a cliff next to a beautiful green meadow. The scenery was overwhelming. The next one had a mud pit and basketball hoop with sprinklers you could run through. We ended up sticking with with the same 30 or so people all day, because we would all leave gradually and end up at the next bar together. Every single bar we went to, including the first one, claimed to be “the last bar”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/river2.jpg&quot; alt=&quot;river&quot; /&gt; &lt;em&gt;&lt;center&gt; Can you guess what I lost in the river? &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The rest of the day was so incredible, I’m at a loss trying to describe it. At one of the “last bar”s we ended up wandering to a path that led up the mountain. Me and this guy David, I forget where he was from … Spain or something, decided to see where it led. So we convinced Sarah and Ryan to follow us, and we started hiking up this rocky trail in the jungle, barefoot and in our bathing suits. We had no idea how long it was but the further we went the more we felt compelled to keep going. We didn’t have any of our things so we were using imaginary cameras to save mental snapshots :). I can’t even tell you what we found when we reached the top because it was too cool and nothing I say can adequately describe it. Haha isn’t that annoying? Go to Laos and see for yourself! :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/crib.jpg&quot; alt=&quot;river&quot; /&gt; &lt;em&gt;&lt;center&gt; &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;At the start of the day, we intended to be back by 6:00 so our deposits would be refunded. By 4:00 I was having so much fun that I decided I couldn’t care less about the deposit. By then, I had caught on to the “Last Bar” trick, so I didn’t think twice about floating right past the actual last bar. I was too busy giggling and hanging my head back over my tube to watch the upsidedown mountains glide through the sunset. At the time, “floating back to town” seemed like a perfectly reasonable idea.&lt;/p&gt;

&lt;p&gt;Once the sun set, the light started dissapearing really quickly. Chaos ensued; for a few moments I was seriously concerned that I’d be forced to spend the night in my bathing suit, in the jungle, with the two strangers I recruited as my buddy system. I thought Sarah and Ryan had gotten out of the river a while ago, but later I found out they got back in to look for me. We ended up reuniting at a tuktuk when we heard eachother’s voices in the darkness. That is another story I can’t do justice to. Obviously I made it but staying in the river that late was stupid.&lt;/p&gt;

&lt;p&gt;The next morning, we had breakfast at Friends Bar, a resturaunt with a bunch of table/cushion/couch/bed things that all face two tvs playing episodes of Friends. You can just chill in these things and eat and watch friends for hours. It’s pretty awesome. Then we layed in the hammocks and ate Rambuttan and chatted until my mini bus came to pick me up. I was sad to leave so soon, but it was an unforgetable trip nonetheless.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kadie16/kadie16.github.io/raw/master/assets/images/posts/laos/back1.jpg&quot; alt=&quot;river&quot; /&gt; &lt;em&gt;&lt;center&gt; Having too much fun&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Jul 2015 00:00:00 -0700</pubDate>
        <link>http://kadie16.github.io/laos/</link>
        <guid isPermaLink="true">http://kadie16.github.io/laos/</guid>
        
        <category>Vientiane</category>
        
        <category>VangVieng</category>
        
        
        <category>abroad</category>
        
        <category>laos</category>
        
      </item>
    
      <item>
        <title>I&#39;m working, I swear!</title>
        <description>&lt;p&gt;So far all I’ve mentioned are the adventures I’ve been having! If you’re wondering, as my Grandpa Joe put it: “when the hell are you going to work”, then this post is for you :)&lt;/p&gt;

&lt;h1 id=&quot;about-my-project&quot;&gt;About My Project&lt;/h1&gt;
&lt;p&gt;I am building a program that will allow users to load 3D models (.obj file format) and interact with them via transformations such as rotation, translation, deformation etc. My ultimate goal is to implement the ability to select parts of a volume mesh, so the user can select and interact with seperate parts of their model. I am using C++, OpenGL, and QT for my project.&lt;/p&gt;

&lt;p&gt;I was first inspired to learn about computer graphics when my (amazing) materials science professor told me about his son who works on lighting movies at Pixar. I have always loved developing my technical background, but I also love painting and drawing and creating visual things. Until I learned about the opportunity to work in computer graphics, it never occurred to me that I could excercise both of my interests at the same time.&lt;/p&gt;

&lt;p&gt;I have virtually no experience with C++, definitely none with OpenGL and I hadn’t even heard of QT until my supervisor told me about it. It is also my first time building a GUI (Graphical User Interface … the window and buttons). Initially, I was feeling a little lost and intimidated while trying to familiarize myself with all three new things simultaneously. So I completeley understand if this is too much computer science jargon. I won’t be offended if you just look at the pictures. But hopefully some of you will find this interesting :)&lt;/p&gt;

&lt;p&gt;After a lot confusion (days), my supervisor helped me organize my learning strategy and I finally got a program running.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/i-swear/0triangle.PNG&quot; alt=&quot;Triangle&quot; /&gt; &lt;em&gt;&lt;center&gt;Nothing special, just a rotating triangle with a quit button, but this was exciting haha :)&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Next I worked on loading actual objects. To do this, I needed to read information from a user selected .obj file. These files are lists of the vertices (lines beginning with v), and faces (lines beginning with f). Each face is a triangle, made up of three of the vertices.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; 

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;  

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; 

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;center&gt;Part of the .obj file for a cube. The first face is using vertices 1, 7, and 5 (which I deleted to make this example smaller).&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Once I have all of the information from the file stored, I have to iterate through each face and ask OpenGL to draw the respective triangle. I’ve been using some models from the &lt;a href=&quot;http://graphics.berkeley.edu/resources/GarmentLibrary/&quot;&gt;Berkeley Garment Library&lt;/a&gt; as test files.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* So OpenGL knows I want it to draw triangles */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBegin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_TRIANGLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;cm&quot;&gt;/* For every Face : */&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;faces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;cm&quot;&gt;/* Get vertices from the Face */&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;faces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

                &lt;span class=&quot;cm&quot;&gt;/* Rendering, aka Drawing, the Face (OpenGL Stuff) */&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;glColor4f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Color it Cyan for Fun  &lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;glVertex3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;glVertex3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;glVertex3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/i-swear/1robe.png&quot; alt=&quot;Robe1&quot; /&gt; &lt;em&gt;&lt;center&gt;Yeah, pink and cyan. I&#39;ll change to neutral colors later, OK?&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yay!! I’ve rendered a model! But it isn’t very exciting looking. It’s supposed to look 3D. It looks flat because it hasn’t been lit yet. If you draw a sphere on a piece of paper, and paint it all one color, it looks like a circle. You need to add lighting and shading to make it look like a sphere, right? Same idea. Cool, I’ll enable lighting.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;glEnable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_LIGHTING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/i-swear/2robe.png&quot; alt=&quot;Robe2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ok so enabling lighting isn’t enough. Now all of the models I load are just black. At this point, OpenGL has no idea how this model is supposed to be lit. I can’t just expect OpenGL to know that my vertices are supposed to look like a robe.&lt;/p&gt;

&lt;p&gt;In order to really light the model, OpenGL needs the normals for each vertex. A normal is a vector that is perpendicular to the face, that points outward. Knowing this, OpenGL can determine where each vertex is actually facing at any given position of the model, and depict the light accordingly. For the most accurate, smooth shading, the normal for each vertex should be an average of the normals of all of the faces that the vertex belongs to. But right now, for simplicity I am just using one.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/i-swear/3dress.png&quot; alt=&quot;Dress3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Cool! Now the models are starting to take some shape :) But obviously something is still wrong. After a couple hours, I realized there was a [1] that was supposed to be a [0] in my normal calculations.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/i-swear/4angel.png&quot; alt=&quot;Angel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Getting the angel to load was really exciting. This is something I was looking forward to from the beginning, when I just had a triangle. But, the black part is there because the angel is crossing the “clipping plane”. The clipping plane is where OpenGL determines that the face is either too close or too far along the z axis to be drawn. Have you ever played a video game and once you get close to an object it dissapears? So my next task is to make sure that no matter where the coordinates of the model are, my program finds them and displays the model on the screen.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/i-swear/5angelSide.png&quot; alt=&quot;AngelAgain&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;center&gt;Isn&#39;t it neat that this is just a bunch of triangles and normals?&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kadie16/kadie16.github.io/master/assets/images/posts/i-swear/6angel.png&quot; alt=&quot;Angel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;center&gt;Angel data set courtesy of the U.C. Berkeley Computer Animation and Modeling Group.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Jul 2015 00:00:00 -0700</pubDate>
        <link>http://kadie16.github.io/working-I-swear/</link>
        <guid isPermaLink="true">http://kadie16.github.io/working-I-swear/</guid>
        
        <category>C++</category>
        
        <category>Work</category>
        
        <category>Project</category>
        
        <category>OpenGL</category>
        
        <category>Computer</category>
        
        <category>Graphics</category>
        
        <category>QT</category>
        
        
        <category>abroad</category>
        
        <category>project</category>
        
      </item>
    
  </channel>
</rss>
